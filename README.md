<!-- TOC -->
<!-- - [1. 游戏整体逻辑](#1-游戏整体逻辑)
    - [1.1. 出兵逻辑](#11-出兵逻辑)
        - [1.1.1. 需要注意的点](#111-需要注意的点)
        - [1.1.2. 规定路径的寻路](#112-规定路径的寻路)
        - [1.1.3. 如何实现路径点寻路](#113-如何实现路径点寻路)
- [2. 资源管理](#2-资源管理)
    - [2.1. 概述](#21-概述) -->

<!-- /TOC -->

<!-- # 1. 游戏整体逻辑 #
## 1.1. 出兵逻辑 ##
游戏会在两个阵营的固定区域在固定的频率中出兵。小兵只能沿着规定好的轨道进行行走，并按照各个防守塔的顺序向敌方进行进攻。
### 1.1.1. 需要注意的点 ###
对于固定出现的小兵来说，不适合在其死亡之后删除GameObject对象，而应该使用对象池来管理他们，当小兵死亡时，只是将该单位的GameObject的active设为false，当要进行出兵的时候，从对象池中抽取active为false的单位出现在固定区域。
### 1.1.2. 规定路径的寻路 ###
对于小兵来说，他们会固定的走上中下三条路线，不会穿越其中的任何一条，而Unity本身的Navigation导航系统不能对于一个地形进行分区，所以使用area对各个单位行走轨迹进行分区的方法就失败了。

在此，决定用**（伪）路径点寻路**的方法来控制小兵的行走轨迹，下面简单描述一下：

1. 因为小兵身上的行为树需要用到导航系统来对敌对目标进行导航，所以小兵的移动不能完全使用路径点寻路，所以这里加了个“伪”字
2. 对于上中下三条路，他们有一系列这条路上的路径点，当小兵没有遭遇战斗时，会沿着这些路径点进行行走，当小兵遭遇战斗，并且，战斗结束后，小兵会找到离他最近的一个路径点，然后走过去，然后又是沿着 路径点一路走。
3. 关键在于，如何判断小兵的战斗结束了，这里采用判断周围敌人的方法，当周围敌人数量为0，那么就是战斗结束了
4. 走到终点也是一种情况，当走到了路径点的终点，小兵将会停在终点处（一般将终点设置为离敌方基地很近，这样小兵停在终点就会自动向敌方基地进攻）

### 1.1.3. 如何实现路径点寻路 ###
1. 基于一个WayPointManager的MonoBehavior类来管理上中下三路的路径点（使用MonoBehavior的原因是可以在编辑器编辑路径点）
2. 使用一个WayPointUnit来管理 单位上中下路的寻路 、 下一个路径点的寻找 、 寻找自己最近的路径点 功能。
3. 理论上来说，只有要不断的攻打敌方基地的小兵才是需要路径点寻路的，其他野怪或者英雄依然使用unity自带的Navigation导航寻路。所以WayPointsUnit这个类是小兵独有的。但是，如果就此就为小兵设置一个单独的具体类，就未免太过麻烦，这里依旧把WayPointsUnit属性赋予CharacterMono类，只不过只有小兵才对其进行赋值，而其他单位这个属性值均为Null。
4. 使用路径点寻路要改写单位的行为树。之前我的小兵行为树策略是指定敌人进行攻击的行为树，但是因为指定敌人的话，行走路线不能固定，所以要将指定攻击三塔、基地的行为树改造成 沿着路径点 指定行走的行为树，其基本逻辑用以下伪代码实现。

		1 if(周围有敌人){
		2 	攻击、追击周围敌人
		3 	if(如果当前位置离最近的路径点距离大于X){
		4 		返回路径点，不管敌人
		5 	}
		6 }else{
		7 	沿着下一个路径点行走
		8 }

这个AI之所以可以顺利的进攻敌人的基地和三路塔,靠的是1-5行的第一个if,路径点规定一定会走到敌方塔或基地前,固小兵可以顺利进攻这几个位置.  
5. 最近路径点算法: 最近路径点的寻找是整个AI性能的关键之处,在这里,我将这个算法定义为如下情况:

从当前下标往下找,一直找到一个离自己最近的位置,那么"最近路径点"等于离自己最近的位置的路径点的下标+1,这里主要是为了小兵不会走回头路(那会看起来很怪).下面用伪代码来描述:

	for(int i=nowIndex+1;i<wayPoint.Count;i++){
		// 找到离自己最近的路径点的下标,赋值为 nearestPointIndex
	}
	// 将当前路径点(即下一步要走的位置)设置为最近的点的下一个坐标
	nowPoint = nearestPointIndex+1


# 2. 资源管理
## 2.1. 概述
首先要明确在MOBA游戏中,有什么数据/资源是需要我们从外部进行动态读取和更新的.
初步观察,应该是如下数据:

1. 每个单位的属性(hp/mp/攻击力等)
2. 每个单位的模型(各类.obj/.fbx文件)
3. 每个单位的各类贴图(漫反射贴图等)
4. 特效对象,比如好几个GameObject组合起来的特效(如explosion特效)
5. 技能/装备/状态属性(名称,各类属性的设置)
6. UI贴图纹理
7. 各类公式(单位攻击伤害公式,技能伤害公式等)
8. 各类动画、动作文件
9. 音效文件

其中1/5/7可以归类为游戏中的各类数据对象,在外部存储时可以以文本格式存储(即json/xml/excel等格式),这些数据是需要进行动态更新与读取的.(方便对游戏中的各类对象的属性进行实时编辑与修改,方便版本更新)

其中2/3/4/6/8/9为资源文件,可以将它们打包为Unity可以读取的形式(assetbundle或其他打包方法).

综上所述,本游戏主要有两类资源,他们分别是文本类型的资源(json/xml/excel等格式)和assetbunlde类型(或其他)的资源,其中特效对象(prefab)/贴图(texture)/模型(mesh)通过assetbundle打包到外部,方便策划添加/编辑/修改.

最后再通过Unity加载这两类资源到游戏中,通过输入框架,将这些数据/资源文件变为游戏中的各个对象. -->
